---
title: Canvas 绘图不清晰的原因及解决方法
number: '#186'
link: 'https://github.com/tofrankie/blog/issues/186'
created_at: '2023-02-26 16:18:16'
updated_at: '2025-12-06 22:50:18'
labels:
  - 前端
  - '2019'
---
## 为什么图片展示不清晰？

我们知道，图片是有尺寸的，尺寸在生成时就固定了，这个尺寸叫做图片的原始尺寸。

试想一下，一个 100 * 100 的图片，我们将它放大 10 倍，图片会变得没原来那么清晰，对吧。

那么，什么时候图片最清晰呢？答案是：**图片展示尺寸 = 图片原始尺寸**

也就是说，如果我们希望图片（这里指位图）放大 10 倍看起来还足够清晰，放大时应该使用尺寸为 1000 * 1000 图片做展示。

综上，导致图片展示不清晰的原因是：展示尺寸与原始尺寸不一致。

> 当然，这里讨论的前提是图片在原始尺寸下是清晰的。

## 解决 img 不清晰问题

`<img>` 的 width/height、naturalWidth/naturalHeight 分别表示图片的展示宽高、原始宽高。

![](https://cdn.jsdelivr.net/gh/tofrankie/blog@main/images/2025/12/1765005432179.png)


当 width > naturalWidth 的时候，就会有不同程度的模糊，下面提供一些参考（注意考虑兼容性）：

### 图片展示尺寸固定

图片展示尺寸固定，可以通过 [srcset](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Reference/Elements/img#srcset) 属性进行设置，浏览器会根据设备 DPR 自动选择最高清晰可用的版本。

```html
<img 
  src="pic@1x.png"
  srcset="
    pic@1x.png 1x,
    pic@2x.png 2x,
    pic@3x.png 3x
  "
/>
```
### 图片展示尺寸不固定

图片展示尺寸不固定，可以结合 srcset + [sizes](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Reference/Elements/img#sizes) 进行设置：

```html
<img 
  src="pic-800.jpg"
  srcset="
    pic-400.jpg 400w,
    pic-800.jpg 800w,
    pic-1200.jpg 1200w,
    pic-1600.jpg 1600w
  "
  sizes="
    (max-width: 600px) 100vw,
    (max-width: 1024px) 50vw,
    33vw
  "
/>
```

### background-image 图片

如果是 background-image 图片，可以使用 [image-set()](https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Values/image/image-set) 进行设置。

```css
.container {
  background-image: image-set(
    "pic@1x.jpg" 1x,
    "pic@2x.jpg" 2x,
    "pic@3x.jpg" 3x
  );
}
```

## 解决 Canvas 图片不清晰的问题

### 了解像素

以 iPhone 7 为例：

- 屏幕 CSS 像素为：375 * 667
- 屏幕物理像素：750 * 1334（也就是手机分辨率）
- DPR：2（物理像素与 CSS 像素之比）

也就是说，一个 CSS 像素，使用 2 个物理像素进行绘制，因此呈现效果要比同期其他手机好。

如果用一张 375 * 667 尺寸的图片放到 iPhone 7 上显示，其实是“不够清晰”的，此时应该使用 2x 图（也就是 750 * 1334）的图片进行展示，这样才会更清晰。

前面提到「图片展示尺寸 = 图片原始尺寸」时图片最清晰，这里的「图片展示尺寸」其实是指「CSS 尺寸 * DPR」，我们可以转换下公式：

**图片原始图片 = CSS 展示尺寸 * DPR**

套入上边的例子：图片原始尺寸宽度 = 375 * 2，所以确保图片清晰的最佳展示尺寸应该是 750 宽，高度同理。

### 了解可替换元素

> 关于[可替换元素](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Guides/Images/Replaced_element_properties)更多细节可以自行查阅。

`<img />` 也是一个可替换元素。

从一个简单的例子开始：

```html
<img src="example.jpg" />
```

我们没给 img 元素添加任何样式，此时它在文档流中占据的空间取决于图片原始尺寸。

```html
<img src="https://placehold.co/750x1334/png" />
```

这是一张 750 * 1334 尺寸的图片，此时在文档流中占据的空间是 750 * 1334（CSS 像素）。此时文档流中占据的空间和图片实际尺寸是一致的。

```html
<img src="https://placehold.co/750x1334/png" style="width: 375px; height: 667px" />
```

接着，给 img 添加样式限制其宽高，这里改变的其实是「展示尺寸」，此时图片占据文档流的空间是 375 * 667。注意，这样修改样式并未修改图片的原始尺寸，也改不了，因为图片原始尺寸在生成时就固定了。

我们可以将 img 这个可替换元素类比成这样的结构：

```html
<div style="375px; height: 667px">
  <div style="width: 750px; height: 1334px"></div>
</div>
```

我们调整 img 的宽高其实修改的是外层的 div，影响不到内层的 div 宽高。

### 了解 Canvas

Canvas 也是一个可替换元素。

但它跟 img 有点不一样，我们知道图片原始尺寸在生成时就确定了，无法修改，而 Canvas 的原始宽高是可以控制修改的。

```html
<canvas></canvas>
```

首先，Canvas 是有个默认宽高的，300 * 150（CSS 像素），我们不作任何样式修改的情况下，它占据文档流 300 * 150 空间。




未完待续...

## 以下旧内容废弃

说明：本文省略部分非关键代码，麻烦自己补全。

一般情况，在高清屏的设备下，任何绘制 canvas 中的图像、文字、线条、形状都可能会出现模糊的问题。可通过引入 GitHub 中的 [hidpi-canvas](https://github.com/jondavidjohn/hidpi-canvas-polyfill) 有效地解决。

1. 首先去 GitHub 下载 [hidpi-canvas.js](https://github.com/jondavidjohn/hidpi-canvas-polyfill) 文件；
2. 在项目中引入 `hidpi-canvas.js` 文件；
3. 调用 `getPixelRatio()` 函数，得到 `ratio` 值；
4. 在 `drawImage()` 中，将 `width` 和 `height` 乘以 `ratio`；
5. 效果如下，但抱歉，没做对比图！

在部分 iOS 设备中，可能会存在 `image.onload` 失效的问题，会导致无法将图片画到 `canvas` 中。引起该现象的原因可能是：

1、iOS 中存在 `image.onload` 失效的问题（注意：`image.onload` 执行的前提是图片正常加载完成，如果稍微出错，就会执行 `image.onerror` 而不是 `image.onload`）；
2、如果 image.src 是 base64 格式文件，不要设置 `image.crossOrigin = "anonymous"`，可能会出现  `image.onload` 无法执行的问题，从而无法正常画图。

> 关于 onload 失效的问题，看 Stack Overflow 这个解答，可能收获挺多的：[IPhone img onload fails](https://stackoverflow.com/questions/18773531/iphone-img-onload-fails)。

```
<!-- html -->
<div onclick="makeCanvasToPhoto()" style="width: 100px; padding: 10px 30px; background: #eee; text-align: center;">生成图片</div>
<canvas id="canvasBox" style="margin: 50px auto;"></canvas>
<!-- 引入js -->
<script type="text/javascript" src="canvas.js"></script>
<script type="text/javascript" src="hidpi-canvas.min.js"></script>
```

```js
// canvas.js 文件
function makeCanvasToPhoto() {
  const canvas = document.getElementById('canvasBox')
  const context = canvas.getContext('2d')
  const ratio = getPixelRatio(context) // 关键代码
  canvas.width = 300 * ratio // 画布宽度
  canvas.height = 300 * ratio // 画布高度
  const divWidth = 300 * ratio // 用于内容居中
  const divHeight = 300 * ratio // 用于内容居中

  // 画矩形
  context.beginPath()
  context.fillStyle = '#abcdef'
  context.fillRect(0, 0, divWidth, divHeight)
  context.closePath()

  // 图片
  context.beginPath()
  const imgObj = new Image()
  imgObj.crossOrigin = 'anonymous' // 在iOS 9设备中，如果src是base64格式，设置了crossOrigin 属性，会导致无法执行image.onload 而执行image.onerror 函数
  imgObj.src = 'http://img0.imgtn.bdimg.com/it/u=458129248,1588126214&fm=26&gp=0.jpg'
  imgObj.onload = function () {
    const imgWidth = '150'
    const imgHeight = '150'
    context.drawImage(this, 50, 50, imgWidth * ratio, imgHeight * ratio)
  }
  context.closePath()

  // 文本
  context.beginPath()
  context.font = '32px bold'
  context.fillStyle = '#1a1a1a'
  context.textAlign = 'center'
  context.textBaseline = 'middle'
  context.fillText('文本', 50, 240)
  context.closePath()

  context.drawImage(canvas, 0, 0, divWidth, divHeight)
  const base64Obj = canvas.toDataURL('image/png', 1)
  console.log(base64Obj)
}

function getPixelRatio(context) {
  const backingStore =
    context.backingStorePixelRatio ||
    context.webkitBackingStorePixelRatio ||
    context.mozBackingStorePixelRatio ||
    context.msBackingStorePixelRatio ||
    context.oBackingStorePixelRatio ||
    context.backingStorePixelRatio ||
    1
  return (window.devicePixelRatio || 1) / backingStore
}
```

效果如图：

![](https://upload-images.jianshu.io/upload_images/5128488-8cbfb0ff01ad2e09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
