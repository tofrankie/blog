---
title: Canvas 绘图不清晰的原因及解决方法
number: '#186'
link: 'https://github.com/tofrankie/blog/issues/186'
created_at: '2023-02-26 16:18:16'
updated_at: '2025-12-07 00:23:06'
labels:
  - 前端
  - '2019'
---
![配图源自 Freepik](https://cdn.jsdelivr.net/gh/tofrankie/blog@main/images/2025/12/1765036083449.jpg)

## 为什么图片展示不清晰？

我们知道，图片是有尺寸的，在生成时就确定了。在 CSS 中我们叫做图片的原始尺寸。

试想一下，把一张 100 * 100 的图片（位图）放大 10 倍，图片会模糊，对吧。

什么时候图片最清晰呢？答案是：**图片渲染尺寸 = 图片原始尺寸**

换句话说，如果希望图片放大 10 倍仍然足够清晰，应该使用尺寸为 1000 * 1000 图片作展示。

> 本文讨论的前提，图片在原始尺寸下是清晰的。

## 解决 img 不清晰问题

在 `<img>` 通过这样的方式获取图片的渲染尺寸和原始尺寸。

- width/height 渲染宽高
- naturalWidth/naturalHeight 原始宽高。

![](https://cdn.jsdelivr.net/gh/tofrankie/blog@main/images/2025/12/1765005432179.png)


当 width > naturalWidth 的时候，就会有不同程度的模糊。

下面提供一些供参考解决方案（注意考虑兼容性）。

### 图片渲染尺寸是固定的

图片渲染尺寸固定，可以通过 [srcset](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Reference/Elements/img#srcset) 属性进行设置，浏览器会根据设备 DPR 自动选择最高清晰可用的版本。

```html
<img 
  src="pic@1x.png"
  srcset="
    pic@1x.png 1x,
    pic@2x.png 2x,
    pic@3x.png 3x
  "
/>
```
### 图片渲染尺寸是动态的

图片渲染尺寸不固定，可以结合 srcset + [sizes](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Reference/Elements/img#sizes) 进行设置：

```html
<img 
  src="pic-800.jpg"
  srcset="
    pic-400.jpg 400w,
    pic-800.jpg 800w,
    pic-1200.jpg 1200w,
    pic-1600.jpg 1600w
  "
  sizes="
    (max-width: 600px) 100vw,
    (max-width: 1024px) 50vw,
    33vw
  "
/>
```

### background-image 图片

如果是 background-image 图片，可以使用 [image-set()](https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Values/image/image-set) 进行设置。

```css
.container {
  background-image: image-set(
    "pic@1x.jpg" 1x,
    "pic@2x.jpg" 2x,
    "pic@3x.jpg" 3x
  );
}
```

## 解决 Canvas 图片不清晰的问题

### 了解像素

以 iPhone 7 为例：

- 屏幕 CSS 像素：375 * 667
- 屏幕物理像素：750 * 1334（也就是手机分辨率）
- DPR：2（物理像素与 CSS 像素之比）

也就是说，一个 CSS 像素，使用 2 个物理像素进行绘制，因此呈现效果要比同期其他手机好。

如果用一张 375 * 667 尺寸的图片放到 iPhone 7 上显示，其实是“不够清晰”的，此时应该使用 2x 图（也就是 750 * 1334）的图片进行展示，这样才会更清晰。

前面提到，当「图片原始尺寸 = 图片渲染尺寸」时图片显示最清晰，这里的「图片渲染尺寸」其实是指「CSS 尺寸 * DPR」，因此可以转换下公式：

> **图片原始图片 = CSS 尺寸 * DPR**

套入 iPhone 7 的例子：图片原始尺寸宽度 = 375 * 2，所以确保图片清晰的最佳尺寸应该是 750 宽，高度同理。

### 了解可替换元素

> 关于[可替换元素](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Guides/Images/Replaced_element_properties)更多细节可以自行查阅。

`<img />` 是一个可替换元素。

从一个简单的例子开始：

```html
<img src="example.jpg" />
```

▲ 我们没给 img 元素添加任何样式，此时它在文档流中占据的空间取决于图片原始尺寸。

```html
<img src="https://placehold.co/750x1334/png" />
```

▲ 这是一张 750 * 1334 尺寸的图片，此时在文档流中占据的空间是 750 * 1334（CSS 尺寸）。尽管文档流中占据的空间（CSS 像素）和图片实际尺寸是一致的，但由于 DPR 为 2，此时图片显示其实是不清晰的（想象成一张图片放大了 2 倍查看）。

```html
<img src="https://placehold.co/750x1334/png" style="width: 375px; height: 667px" />
```

▲ 接着，给 img 添加样式限制其宽高，这里改变的其实是「渲染尺寸」，此时图片占据文档流的空间是 375 * 667（CSS 尺寸）。注意，这样修改样式并未修改图片的原始尺寸，也改不了，因为图片原始尺寸在生成时就固定了。此时图片显示是清晰的。

我们可以将 img 这个可替换元素类比成这样的结构：

```html
<div style="375px; height: 667px">
  <div style="width: 750px; height: 1334px"></div>
</div>
```

我们调整 img 的宽高其实修改的是外层的 div，影响不到内层的 div 宽高。当然可以使用 [object-fit](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference/Properties/object-fit) 等 CSS 属性影响可替换元素的外层与内存的关系。

### 了解 Canvas

Canvas 也是一个可替换元素。

但它跟 img 有点不一样，我们知道图片原始尺寸在生成时就确定了，无法修改，而 Canvas 的原始宽高是可以控制修改的。

```html
<canvas></canvas>
```

首先，Canvas 是有个默认宽高的，300 * 150（Canvas 原始尺寸），我们不作任何样式修改的情况下，它占据文档流 300 * 150 空间（取决于 Canvas 的原始尺寸）。

举个例子，我们使用 Canvas 进行绘图时，通常会进行类似的初始化处理：

```html
<canvas id="canvas"></canvas>
```

```css
#canvas {
  width: 375px;
  height: 667px;
}
```

```js
const canvas = document.getElementById('canvas')
const ctx = canvas.getContext('2d')

const elementWidth = canvas.clientWidth
const elementHeight = canvas.clientHeight

const dpr = window.devicePixelRatio ?? 1
ctx.canvas.width = elementWidth * dpr // 可以使用 canvas.width = elementWidth * dpr
ctx.canvas.height = elementHeight * dpr // 可以使用 canvas.height = elementHeight * dpr

ctx.scale(dpr, dpr)

// 各种绘制...
```

这里做了几件事：

1. 通过 CSS 修改了 Canvas 元素在文档流占据的空间，设为 375 * 667
2. 通过 `ctx.canvas.width = elementWidth * dpr` 和 `ctx.canvas.height = canvas.clientHeight` 修改了 Canvas 的原始尺寸，确保文档流占据的空间与 Canvas 原始尺寸保持正比，以避免显示变形。（如果没有理解，想象一下在 100 * 100 的 img 元素中放了一张 100 * 200 的图片的场景，此时图片显示会变形）
3. 使用 `CanvasRenderingContext2D.scale()` 对 Canvas 的坐标系进行放大，放大了 N 倍（取决于设备 DPR），以确保后续绘制按相同的比例进行下去

为什么要这样做？

回顾这条公式：**图片原始图片 = CSS 尺寸 * DPR**

> 我们在内心把 Canvas 绘制出来的图形当作一张图片。

前面，如果要在不同 DPR 设备下使得 img 的图片清晰显示，我们的解决方法是使用不同尺寸的图片。

我们把 Canvas 本身当作一张图片。针对不同 DPR 的设备，不需要换图解决，使用 Canvas 提供的 API 就能轻松修改其（原始）尺寸。也就是 `ctx.canvas.width = elementWidth * dpr` 和 `ctx.canvas.height = canvas.clientHeight` 所做的事情。

以 iPhone 7 为例，图片原始宽度（ctx.canvas.width）= 375 * 2 = 750，高度同理。

类比成 div：

```html
<div style="375px; height: 667px">
  <!-- 750 = 375 * DPR -->
  <!-- 1134 = 667 * DPR -->
  <div style="width: 750px; height: 1334px"></div>
</div>
```

接着，如果我们初始化过程如下：

```js
// 不用
// ctx.canvas.width = elementWidth * dpr
// ctx.canvas.height = elementHeight * dpr

// 改用
canvas.style.width = elementWidth * dpr + 'px'
canvas.style.height = elementHeight * dpr + 'px'
```

它相当于修改了：

```css
#canvas {
  width: 750px;
  height: 1334px;
}
```

使用 div 两层结构类比，它修改的是外层 div 的尺寸，此时效果相当于：把一张 300 * 150 尺寸的图片放到了一个 750 * 1334 尺寸的 img 容器中，图片显示会变形，且在高清屏下显示不清晰。

### Canvas 绘制不清晰的原因

理解了上一节的内容，就很好理解并知道为什么要这样处理。

如果在高清屏下 Canvas 绘制模糊，原因大概率是没有进行以下两部处理（多数可能是没有乘以 DPR）：

```js
// 1. 仅确保了 Canvas 的实际尺寸跟文档流占据的空间一致，以避免变形
ctx.canvas.width = elementWidth * dpr
ctx.canvas.height = elementHeight * dpr
// 2. 确保后续绘制以相同的比例进行
ctx.scale(dpr, dpr)
```

如果在 Canvas 上绘制一张图片，还要检查图片本身是否清晰。

## 总结

记住这两个结论：

- **当图片原始尺寸 = 图片渲染尺寸时，图片在屏幕上显示最清晰**
- **图片原始尺寸 = CSS 尺寸 * DPR**


## 旧内容废弃

<details>
<summary>Deprecated</summary>

说明：本文省略部分非关键代码，麻烦自己补全。

一般情况，在高清屏的设备下，任何绘制 canvas 中的图像、文字、线条、形状都可能会出现模糊的问题。可通过引入 GitHub 中的 [hidpi-canvas](https://github.com/jondavidjohn/hidpi-canvas-polyfill) 有效地解决。

1. 首先去 GitHub 下载 [hidpi-canvas.js](https://github.com/jondavidjohn/hidpi-canvas-polyfill) 文件；
2. 在项目中引入 `hidpi-canvas.js` 文件；
3. 调用 `getPixelRatio()` 函数，得到 `ratio` 值；
4. 在 `drawImage()` 中，将 `width` 和 `height` 乘以 `ratio`；
5. 效果如下，但抱歉，没做对比图！

在部分 iOS 设备中，可能会存在 `image.onload` 失效的问题，会导致无法将图片画到 `canvas` 中。引起该现象的原因可能是：

1、iOS 中存在 `image.onload` 失效的问题（注意：`image.onload` 执行的前提是图片正常加载完成，如果稍微出错，就会执行 `image.onerror` 而不是 `image.onload`）；
2、如果 image.src 是 base64 格式文件，不要设置 `image.crossOrigin = "anonymous"`，可能会出现  `image.onload` 无法执行的问题，从而无法正常画图。

> 关于 onload 失效的问题，看 Stack Overflow 这个解答，可能收获挺多的：[IPhone img onload fails](https://stackoverflow.com/questions/18773531/iphone-img-onload-fails)。

```
<!-- html -->
<div onclick="makeCanvasToPhoto()" style="width: 100px; padding: 10px 30px; background: #eee; text-align: center;">生成图片</div>
<canvas id="canvasBox" style="margin: 50px auto;"></canvas>
<!-- 引入js -->
<script type="text/javascript" src="canvas.js"></script>
<script type="text/javascript" src="hidpi-canvas.min.js"></script>
```

```js
// canvas.js 文件
function makeCanvasToPhoto() {
  const canvas = document.getElementById('canvasBox')
  const context = canvas.getContext('2d')
  const ratio = getPixelRatio(context) // 关键代码
  canvas.width = 300 * ratio // 画布宽度
  canvas.height = 300 * ratio // 画布高度
  const divWidth = 300 * ratio // 用于内容居中
  const divHeight = 300 * ratio // 用于内容居中

  // 画矩形
  context.beginPath()
  context.fillStyle = '#abcdef'
  context.fillRect(0, 0, divWidth, divHeight)
  context.closePath()

  // 图片
  context.beginPath()
  const imgObj = new Image()
  imgObj.crossOrigin = 'anonymous' // 在iOS 9设备中，如果src是base64格式，设置了crossOrigin 属性，会导致无法执行image.onload 而执行image.onerror 函数
  imgObj.src = 'http://img0.imgtn.bdimg.com/it/u=458129248,1588126214&fm=26&gp=0.jpg'
  imgObj.onload = function () {
    const imgWidth = '150'
    const imgHeight = '150'
    context.drawImage(this, 50, 50, imgWidth * ratio, imgHeight * ratio)
  }
  context.closePath()

  // 文本
  context.beginPath()
  context.font = '32px bold'
  context.fillStyle = '#1a1a1a'
  context.textAlign = 'center'
  context.textBaseline = 'middle'
  context.fillText('文本', 50, 240)
  context.closePath()

  context.drawImage(canvas, 0, 0, divWidth, divHeight)
  const base64Obj = canvas.toDataURL('image/png', 1)
  console.log(base64Obj)
}

function getPixelRatio(context) {
  const backingStore =
    context.backingStorePixelRatio ||
    context.webkitBackingStorePixelRatio ||
    context.mozBackingStorePixelRatio ||
    context.msBackingStorePixelRatio ||
    context.oBackingStorePixelRatio ||
    context.backingStorePixelRatio ||
    1
  return (window.devicePixelRatio || 1) / backingStore
}
```

效果如图：

![](https://upload-images.jianshu.io/upload_images/5128488-8cbfb0ff01ad2e09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
</details>
